import os
import zmq
import logging
import json
import sys
import time
from pyevents.events import get_plugin_socket, get_next_msg, send_quit_command
from ctevents.ctevents import socket_message_to_typed_event, send_terminate_plugin_fb_event
from ctevents import ImageStoredEvent, ImageDeletedEvent, ImageScoredEvent, ImageReceivedEvent, PluginTerminatingEvent
from filelock import FileLock


log_level = os.environ.get("ORACLE_LOG_LEVEL", "INFO")
logger = logging.getLogger("Oracle Monitor")
if log_level == "DEBUG":
    logger.setLevel(logging.DEBUG)
elif log_level == "INFO":
    logger.setLevel(logging.INFO)
elif log_level == "WARN":
    logger.setLevel(logging.WARN)
elif log_level == "ERROR":
    logger.setLevel(logging.ERROR)
if not logger.handlers:
    formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s '
            '[in %(pathname)s:%(lineno)d]')
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    logger.addHandler(handler)

# Number of images generated by the entire application (i.e., by the image generating plugin)
total_images_generated = 0

# Number of images processed by this oracle plugin 
total_images_processed = 0

# Whether this program has received the PLuginTerminating event from the image generating plugin
received_terminating_signal = False

# list of image UUIDs for which the oracle plugin is not able to initially retrieve the basic information 
# from the uuid_image_mapping file (written by image generating plugin)
uuids_with_errors = []

PORT = int(os.environ.get('ORACLE_PLUGIN_PORT', 6011))
OUTPUT_DIR = os.environ.get('TRAPS_ORACLE_OUTPUT_PATH', "/output/")
MODEL_ID = os.environ.get("MODEL_ID")


# This is the ground truth file; this file is written by the image generating plugin and only read
# by the oracel plugin (not written to)
uuid_image_mapping_path = os.path.join(OUTPUT_DIR, "uuid_image_mapping.json")

# This is the file the oracle plugin actually writes
output_file = os.path.join(OUTPUT_DIR, "image_mapping_final.json")


SOCKET_TIMEOUT = 2000


def get_socket():
    context = zmq.Context()
    return get_plugin_socket(context, PORT)  

def compute_total_images_generated():
    """
    Reads the uuid_image_mapping file to determine how many images were generated by this execution.
    """
    with open(uuid_image_mapping_path, 'r') as f:
        try:
            d = json.load(f)
        except Exception as e:
            logger.error(f"Error parsing uuid_image_mapping file when trying to compute total images generated; details: {e}")
            return -1 
    # the number of images generated is just the total number of keys in the file
    return len(d.keys())


def compute_total_images_processed():
    """
    Reads the image_mapping_final file to determine how many images have been processed.
    """
    total = 0
    with open(output_file, 'r') as f:
        try:
            d = json.load(f)
        except Exception as e:
            logger.error(f"Error parsing image_mapping_final file when trying to compute total images processed; details: {e}")
            return total
    # read through the entries and count all images which have a final decision
    for _, v in d.items():
        if v.get("image_decision"):
            total += 1
    return total


def update_json(uuid, updated_data):
    """
    This function updates the existing image_mapping_final dictionary for a given image with id, `uuid`, 
    and a dictionary, `updated_data`, with additional fields to write for the image. 
    """
    global total_images_processed, total_images_generated
    
    lock = FileLock(f'{uuid_image_mapping_path}.lock')
    # load current dictionary from the image_mapping_final file 
    existing_image_mapping_final = {}
    try:
        with open(output_file, 'r') as f:
            try:
                existing_image_mapping_final = json.load(f)
            except json.JSONDecodeError as e:
                logger.error(f"JSON decoding error for {output_file}; details: {e}")        
    except FileNotFoundError:
        # for the first image, the file has not been created yet and FileNotFound is expected
        if not total_images_processed == 0:
            logger.error(f"File not found: {output_file}")

    # if the uuid is not yet in the image_mapping_final file, go to the uuid_image_mapping file, written
    # by the image generating plugin, to get basic information. The uuid should always be in this file 
    # since the image generating plugin writes the uuid to that file before sending a new image event, 
    if uuid not in existing_image_mapping_final:
        logger.info(f"Fetching {uuid} from {uuid_image_mapping_path}")
        uuid_image_mapping = {}
        try:
            with lock:
                with open(uuid_image_mapping_path, 'r') as file:
                    try:
                        uuid_image_mapping = json.load(file)
                        # If we were able to load the uuid_image_mapping file, try to recover any UUID that
                        # was previously on the error list
                        if uuids_with_errors:
                            for failed_uuid in uuids_with_errors:
                                existing_image_mapping_final[failed_uuid] = uuid_image_mapping[failed_uuid]
                                uuids_with_errors.remove(failed_uuid)

                    # it is possible the image generating plugin was writing to the file at the same time and,
                    # at the moment we read the file, the contents of the file are not valid JSON.
                    except json.JSONDecodeError as e:
                        logger.error(f"JSON loading Error loading uuid_image_mapping.json file while processing uuid: {uuid}; details: {e}")
                        # we were not able to read the uuid_image_mapping.json file, so add this uuid to the error list
                        uuids_with_errors.append(uuid)
        except FileNotFoundError:
            # ths uuid_image_mapping file shoud always at least exist
            logger.error(f"File {uuid_image_mapping_path} not found. This is unexpected and represents a bug.")

        # use the uuid_image_mapping file to get the base info for this image, if possible, and otherwise,
        # create a new dictionary with just the UUID field.
        existing_image_mapping_final[uuid] = uuid_image_mapping.get(uuid, {"UUID": uuid})

    # iterate through the update_data parameter and add them to the existing data
    for key, value in updated_data.items():
        existing_image_mapping_final[uuid][key] = value    
    
    # write the updates mapping back to the file
    with open(output_file, "w") as f: 
        json.dump(existing_image_mapping_final, f, indent=2)


def add_terminating_function_json(special_uuid):
    """
    This function writes a 'special' UUID that the CKN daemon looks for to know when to exit. 
    It first checks one last time for images in the uuids_with_errors file and tries to retrieve 
    them 

    """
    lock = FileLock(f'{uuid_image_mapping_path}.lock')
    # read the existing output data 
    with open(output_file, "r") as f: 
        existing_image_mapping_final = json.load(f)
    
    # check if we still have UUIDs with errors
    if uuids_with_errors:
        uuid_image_mapping = {}
        # try to read the mapping file and make the corrections
        try:
            with lock:
                with open(uuid_image_mapping_path, 'r') as file:
                    try:
                        uuid_image_mapping = json.load(file)
                    except Exception as e:
                        logger.error(f"Could not load JSON from uuid_image_mapping file at the very end; details: {e}")
        except Exception as e:
            logger.error(f"Got exception trying to open the uuid_image_mapping file at the very end; details: {e}")
        if uuid_image_mapping:
            for failed_uuid in uuids_with_errors:
                # we should always have SOME data for all failed uuids, so this 
                if not existing_image_mapping_final.get(failed_uuid):
                    existing_image_mapping_final[failed_uuid] = {}
                    logger.error(f"In final processing and existing_image_mapping_final had no data for uuid {failed_uuid}")
                # extend the existing mapping data with the uuid data
                existing_image_mapping_final[failed_uuid].update(uuid_image_mapping[failed_uuid])
                uuids_with_errors.remove(failed_uuid)
                logger.info(f"Updated final mapping at the end for failed UUID {failed_uuid}")

    # add the special UUID to the mapping file; it gets an empty dict since it does not correspond to a 
    # real image
    existing_image_mapping_final[special_uuid] = {}
    
    # write the complete mapping file:
    with open(output_file, "w") as f: 
        json.dump(existing_image_mapping_final, f, indent=2)


def main():
    """
    Main loop for oracle plugin; this function waits for new messages on the event socket and processes accordingly:
      1. Image received, scored, stored, deleted: update the image_mapping_final
      2. Plugin terminating (from image generating): Compute total images needed to be processed.
    """
    done = False
    while not done:
        socket = get_socket()
        try:
            message = get_next_msg(socket)
        except zmq.error.Again:
            logger.debug(f"Got a zmq.error.Again; i.e., waited {SOCKET_TIMEOUT} ms without getting a message")
            continue
        except Exception as e:
            logger.debug(f"Got exception from get_next_msg; type(e): {type(e)}; e: {e}")
            done = True 
            logger.info("Oracle monitoring plugin stopping due to timeout limit...")
            continue
        if not message:
            logger.info("No message found in get_next_msg")

        logger.info("Got a message from the event socket - Oracle monitor check")
        event = socket_message_to_typed_event(message)

        if isinstance(event, ImageReceivedEvent):
            uuid = event.ImageUuid().decode('utf-8')
            timestamp = event.EventCreateTs().decode('utf-8').strip("'")
            logger.info(f"Image received {uuid} {timestamp}")
            update_json(uuid, {"image_receiving_timestamp": timestamp})

        elif isinstance(event, ImageScoredEvent):
            uuid = event.ImageUuid().decode('utf-8')
            scores = [] # event.ScoresLength()
            for i in range(event.ScoresLength()):
                label = event.Scores(i).Label().decode('utf-8')
                prob = event.Scores(i).Probability()
                scores.append({"label": label, "probability": prob})
            timestamp = event.EventCreateTs().decode('utf-8')
            logger.info(f"Inside scoring {uuid} {scores} {timestamp}")
            update_json(uuid, {"image_scoring_timestamp": timestamp, "score" : scores})

        elif isinstance(event, ImageStoredEvent):
            uuid = event.ImageUuid().decode('utf-8')
            timestamp = event.EventCreateTs().decode('utf-8')
            destination = event.Destination().decode('utf-8')
            logger.info(f"Image stored {uuid} {timestamp} {destination}")
            update_json(uuid, {"image_store_delete_time": timestamp, "image_decision": destination})

        elif isinstance(event, ImageDeletedEvent):
            uuid = event.ImageUuid().decode('utf-8')
            timestamp = event.EventCreateTs().decode('utf-8')
            logger.info(f"Image deleted {uuid} {timestamp}")
            update_json(uuid, {"image_delete_time": timestamp, "image_decision": "Deleted"})

        elif isinstance(event, PluginTerminatingEvent):
            plugin_name = event.PluginName().decode('utf-8')
            if plugin_name == 'ext_image_gen_plugin':
                logger.info("Received Terminating signal from image generating plugin")
                # at this point, we can compute the total images generated and to be processed from the
                # length of the uuid_image_mapping
                global received_terminating_signal
                received_terminating_signal = True
                total_images_generated = compute_total_images_generated()
                logger.info(f"Total images processed: {total_images_generated}")
        
        # Once we have received the terminating signal, we compute total_images_processed 
        if received_terminating_signal:
            total_images_processed = compute_total_images_processed()
            logger.info(f"Oracle has processed: {total_images_processed} out of {total_images_generated}")
            if total_images_generated < 0:
                total_images_generated = compute_total_images_generated()
       
        if received_terminating_signal \
        and total_images_generated > 0 \
        and total_images_generated == total_images_processed:
            logger.info("Initiating shut down for all other plugins...")
            add_terminating_function_json("6e153711-9823-4ee6-b608-58e2e801db51")
            send_terminate_plugin_fb_event(socket, "*", "6e153711-9823-4ee6-b608-58e2e801db51")
            logger.info("Sent PluginTerminate * event")
            time.sleep(1)
            send_quit_command(socket)
            logger.info("Sent quit command.")
            sys.exit()
            #Leaving the uuid empty/* throws an error[Unable to parse string 'target_plugin_uuid' into a Uuid: invalid character: expected an optional prefix of `urn:uuid:`]
            #send_terminating_plugin_fb_event(socket,"ext_oracle_monitor_plugin","6e153711-9823-4ee6-b608-58e2e801db51")
        else:
            logger.info(event)

if __name__ == '__main__':
    logger.info("Oracle plugin starting...")
    main()
    logger.info("Oracle plugin exiting...")
